---
title: "Post-election workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Post-election workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ausvotesfeed)
library(dplyr)
library(tidyr)
```

This is a walk-through of a post-election workflow of accessing results from the AEC's Virtual Tally Room (VTR) media feed based around `ausvotesfeed`.

It is designed to show you how to setup candidate, party, division and polling place tables from the pre-load files, complete with historic election results and 'ghost' candidates (candidates from previous elections that are not contesting the current election, which are included for the purpose of calculating swings).

Once these tables are set up it is possible to extract results from the media feeds as they become available in a relatively minimal and (importantly) quick format, and to merge those results with the preload tables.

## Pre-load details

The media feed is hosted on an anonymous FTP server. During the election the AEC makes the live results available on [ftp://mediafeed.aec.gov.au], however that site is only available during the election. The rest of the time there is an archive of old media feeds available at [ftp://mediafeedarchive.aec.gov.au]. 

The functions that access the files on the media feed take this into account, and during the election period if the `Archive` switch is set to `FALSE` the files on the media feed for the active election will be used. At all other times, set `Archive` to `TRUE` (the default). 

Download the most recent preload file from the media feed:

```{r download}
preload_xml <- read_mediafeed_xml(download_mediafeed_file(2022, 
                                                          Filetype = "Preload",
                                                          Archive = TRUE),
                                  filename = "results")
```

The zip file for the preload has a number of files, and so when `read_mediafeed_xml()` is used with a preload file, it will require a `filename` to be specified. 

Anonymous FTP is somewhat archaic and is often blocked for security reasons. In order to get around this, the package includes some files that are installed into the `plumber` folder of the package which will create an API server to relay the media feed files. 

Hopefully you don't need this, but if you do, run the `plumber` files on a server that can access the FTP site and use `download_mediafeed_api()` as a drop-in replacement for `download_mediafeed_file()`.

```{r download_api, eval=FALSE, include=FALSE}
results_xml <- read_mediafeed_xml(download_mediafeed_api("http://ausvotes.org:7995", 
                                                         2022, 
                                                         Filetype = "Verbose", 
                                                         Archive = FALSE))
```

The `read_mediafeed_xml()` function provides an `xml2` pointer to the resulting XML file, and is designed to be a replacement for `read_xml()` from that package that works with the particular combination of files returned by the mediafeed. 

Check when the file was created. The time strings used throughout the media feed can be converted to R time objects using `%FT%T` as a format string. Generally the functions should return `POSIXct` time objects where the media feed returns a date stamp, but this is handy for when it does.

```{r metadata}
as.POSIXct(get_mediafeed_metadata(preload_xml)["Created"], format = "%FT%T")
```

### Populate pre-load tables

A series of (relatively) slow functions extract all of the relevant election information from the preload files, which can then be merged with results particularly by `CandidateID`, `DivisionID` and `PollingPlaceID` (which should always be returned as `INT`).

#### Candidates

The candidates extract also includes first preference votes, although only the historic votes are non-zero.

```{r preload_cand}
mf_cand <- get_mediafeed_preload_candidates(preload_xml)

head(mf_cand)
```

Gender is available from the `candidates` file in the preload zip file. If you want to include it with the candidates data.frame, use `get_mediafeed_preload_gender()` and merge it on `CandidateId`. 

Note that there is no available gender for _ghost_ candidates.

```{r preload_gender}
cand_xml <- read_mediafeed_xml(download_mediafeed_file(2022, 
                                                       Filetype = "Preload",
                                                       Archive = TRUE),
                               filename = "candidates")

mf_cand <- mf_cand %>% 
  left_join(get_mediafeed_preload_gender(cand_xml, "House") %>% 
  select(CandidateID, Gender),
  by = "CandidateID")

head(mf_cand)
```

#### Divisions

```{r preload_div}
mf_div <- get_mediafeed_preload_divs(preload_xml)

head(mf_div)
```

#### Polling places

In practice, this is probably more useful than the division table for most purposes because it includes both division (`DivisionNm` and `DivisionId`) and state (`StateAb`).

```{r preload_pps}
mf_pps <- get_mediafeed_preload_pps(preload_xml)

head(mf_pps)
```
The media feed does not include the geocodes of the polling places for some reason, but that is available from the VTR and can be merged with the results of this function. It also includes a PollingPlaceTypeID, which can be handy.

```{r preload_geocodes}
tmp_pps <- download_file_vtr("GeneralPollingPlacesDownload", 27966, "https://tallyroom.aec.gov.au/Downloads/")

head(tmp_pps)

mf_pps <- mf_pps %>% 
  left_join(tmp_pps %>% 
              select(-PollingPlaceNm) %>% 
              rename(StateAb = State),
            by = c("DivisionID", "PollingPlaceID"))

rm(tmp_pps)
```


The actual results file returns a table of each candidate for each polling place, and the `get_mediafeed_preload_pps_cand()` function returns a table in that format, which can be easily merged with the results when they are retrieved. It can take a while to run.

Unfortunately this is not possible for the TCP results, because TCP candidates are not included in the preload file. 
```{r preload_pps_cand}
mf_pps_cand <- get_mediafeed_preload_pps_cand(preload_xml)

head(mf_pps_cand)

```


#### Votes by type

```{r preload_votes_type}
mf_votes <- get_mediafeed_preload_votes_type(preload_xml)

head(mf_votes)
```

It makes sense to save these so you can access them later.

```{r}
save(list = ls(pattern = "mf_"), file = "preload_2022.rds")
```


## Election results

```{r download_results}
results_xml <- read_mediafeed_xml(download_mediafeed_file(2022, 
                                                          Filetype = "Verbose",
                                                          Archive = FALSE))
```

Another way to do this if you just want to quickly get the results of the current election is:

```{r eval=FALSE, include=FALSE}
results_xml <- fetch_mediafeed_results(2022)
```

### Results by polling place

This is perhaps the slowest operation, which is the votes by polling place. But it essentially provides everything you need to do most analysis.

```{r votes_pps}
votes_pps_fp <- get_mediafeed_votes_pps_fp(results_xml)
votes_pps_tcp <- get_mediafeed_votes_pps_tcp(results_xml)
```

Merge these with the results of `get_mediafeed_preload_pps()` for analysis by state and division, but note that this file does not include the votes by type. We need to get those separately.

```{r}
votes_pps_fp <- votes_pps_fp %>% 
  left_join(mf_pps, by = "PollingPlaceID")

head(votes_pps_fp)
```

```{r}
votes_pps_tcp <- votes_pps_tcp %>% 
  left_join(mf_pps, by = "PollingPlaceID")

head(votes_pps_tcp)
```

Check how many seats we have a TCP leader for (it should be 151).

```{r}
get_mediafeed_votes_div(results_xml, "tcp") %>% 
  filter(TCP.Percentage >= 50) %>% 
  summarise(n = n())
```

### Results by candidate

Candidates newly elected to Parliament.

```{r newly_elected}
get_mediafeed_votes_div(results_xml, "tcp") %>% 
  left_join(mf_cand, by = c("CandidateID", "DivisionID")) %>% 
  filter(TCP.Percentage >=50 & ElectedHistoric == FALSE) %>% 
  select(StateAb, DivisionNm, CandidateNm, IsIndependent, PartyNm)
```

Seats that have changed hands.

```{r changed_hands}
get_mediafeed_votes_div(results_xml, "tcp") %>% 
  left_join(mf_cand, by = c("CandidateID", "DivisionID", "CandidateType")) %>% 
  filter(TCP.Percentage >= 50 & ElectedHistoric == FALSE & (Incumbent == FALSE | IncumbentNotional == FALSE)) %>% 
  select(StateAb, DivisionID, DivisionNm, CandidateNm, PartyCode, TCP.Percentage, TCP.Swing) %>% 
  left_join(mf_cand %>% 
              filter(Incumbent == TRUE | IncumbentNotional == TRUE) %>% 
              select(DivisionID, Previous = PartyCode),
            by = "DivisionID")
```

### Gender and parliament

Find out the gender distribution by party for the incoming parliament (based on TCP leading candidate).

```{r gender}
get_mediafeed_votes_div(results_xml, "tcp") %>% 
  left_join(mf_cand, by = c("DivisionID", "CandidateID", "CandidateType")) %>% 
  filter(TCP.Percentage > 50) %>% 
  mutate(PartyCode = ifelse(IsIndependent == TRUE, "Independent", PartyCode)) %>% 
  group_by(PartyCode, Gender) %>% 
  summarise(n = n()) %>% 
  pivot_wider(names_from = Gender, values_from = n, values_fill = 0)
```

### Close seats

Return divisions ordered by the closest TCP margin.

```{r tcp_margin}
get_mediafeed_votes_div(results_xml, "tcp") %>% 
  select(-TCP.Historic, 
         -TCP.MatchedHistoric, 
         -TCP.MatchedHistoricFirstPrefsIn, 
         -CandidateType) %>% 
  arrange(DivisionID, desc(TCP.Percentage)) %>% 
  group_by(DivisionID) %>%
  mutate(TCP.Margin = TCP.Votes - lead(TCP.Votes)) %>% 
  filter(TCP.Percentage > 50) %>% 
  arrange(TCP.Margin)
```

## Two-party preferred by state (and nationally)

This is particularly handy because the AEC does not include national TPP
swings in the CSV files in the VTR.

```{r tpp_swings}
get_mediafeed_votes_div(results_xml, "tpp") |> 
  left_join(mf_div, by = c("DivisionID")) |> 
  group_by(StateAb, CoalitionCode) |> 
  summarise(Historic = sum(TPP.Historic),
            Votes = sum(TPP.Votes), .groups = "drop_last") |> 
  mutate(HistoricPercent = Historic / sum(Historic) * 100,
         Percent = Votes / sum(Votes) * 100,
         Swing = Percent - HistoricPercent) %>% 
  bind_rows(group_by(., CoalitionCode) |> 
              summarise(Historic = sum(Historic), Votes = sum(Votes), .groups = "drop_last") |> 
              mutate(HistoricPercent = Historic / sum(Historic) * 100,
                     Percent = Votes / sum(Votes) * 100,
                     Swing = Percent - HistoricPercent,
                     StateAb = "National")) |> 
  select(StateAb, CoalitionCode, Percent, Swing) |> 
  pivot_wider(names_from = CoalitionCode, values_from = c(Percent, Swing))
```

